from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Customer, Loan
from .serializers import (
    CustomerSerializer,
    LoanSerializer,
    CreateCustomerSerializer,
    CreateLoanSerializer,
)
import pandas as pd
from datetime import date, timedelta


class FillDataAPIView(APIView):
    def post(self, request):
        try:
            customer_df = pd.read_excel('/code/customer_data.xlsx')
            loan_df = pd.read_excel('/code/loan_data.xlsx')

            customers_created = 0
            for _, row in customer_df.iterrows():
                phone_number = row.get('phone_number')
                if not phone_number:
                    continue  # skip if no phone number

                Customer.objects.update_or_create(
                    phone_number=phone_number,
                    defaults={
                        'first_name': row.get('first_name', ''),
                        'last_name': row.get('last_name', ''),
                        'age': int(row['age']) if pd.notna(row.get('age')) else None,
                        'monthly_income': int(row['monthly_income']) if pd.notna(row.get('monthly_income')) else 0,
                        'approved_limit': int(row['approved_limit']) if pd.notna(row.get('approved_limit')) else 0,
                        'current_debt': int(row['current_debt']) if pd.notna(row.get('current_debt')) else 0
                    }
                )
                customers_created += 1

            loans_created = 0
            for _, row in loan_df.iterrows():
                phone_number = row.get('phone_number')
                if not phone_number:
                    continue  # skip if no phone number

                customer = Customer.objects.filter(phone_number=phone_number).first()
                if not customer:
                    continue  # skip if corresponding customer not found

                Loan.objects.update_or_create(
                    # No loan_id field in your model, so use unique fields like id? Assuming 'id' autogenerated.
                    # Use filter for uniqueness criteria, e.g., customer + start_date or loan_amount if needed.
                    defaults={
                        'customer': customer,
                        'loan_amount': float(row['loan_amount']) if pd.notna(row.get('loan_amount')) else 0,
                        'tenure': int(row['tenure']) if pd.notna(row.get('tenure')) else 0,
                        'interest_rate': float(row['interest_rate']) if pd.notna(row.get('interest_rate')) else 0,
                        'monthly_repayment': float(row['monthly_repayment']) if pd.notna(row.get('monthly_repayment')) else 0,
                        'emis_paid_on_time': int(row['emis_paid_on_time']) if pd.notna(row.get('emis_paid_on_time')) else 0,
                        'start_date': pd.to_datetime(row['start_date']).date() if pd.notna(row.get('start_date')) else None,
                        'end_date': pd.to_datetime(row['end_date']).date() if pd.notna(row.get('end_date')) else None,
                        'active': bool(row['active']) if pd.notna(row.get('active')) else True,
                    }
                )
                loans_created += 1

            return Response({
                "message": "Data ingested successfully",
                
            }, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


def calculate_emi(principal, rate, tenure):
    r = rate / (12 * 100)
    if r == 0:
        return round(principal / tenure, 2)
    emi = (principal * r * ((1 + r) ** tenure)) / (((1 + r) ** tenure) - 1)
    return round(emi, 2)


def calculate_credit_score(customer, loans, requested_amount):
    score = 50
    total_emis = sum(loan.tenure for loan in loans)
    on_time_emis = sum(loan.emis_paid_on_time for loan in loans)

    if total_emis > 0:
        on_time_ratio = on_time_emis / total_emis
        if on_time_ratio > 0.9:
            score += 20
        elif on_time_ratio > 0.7:
            score += 10
        elif on_time_ratio > 0.5:
            score += 5
        else:
            score -= 10

    if len(loans) > 5:
        score -= 10
    elif len(loans) > 2:
        score -= 5

    current_year = date.today().year
    current_year_loans = [loan for loan in loans if loan.start_date and loan.start_date.year == current_year]
    if current_year_loans:
        score -= 5

    total_loan_vol = sum(loan.loan_amount for loan in loans)
    if total_loan_vol > customer.approved_limit:
        score = 0

    sum_debt = sum(loan.loan_amount for loan in loans if loan.active)
    if sum_debt + requested_amount > customer.approved_limit:
        score = 0

    return max(score, 0)

class RegisterCustomer(APIView):
    def post(self, request):
        serializer = CreateCustomerSerializer(data=request.data)
        if serializer.is_valid():
            # Calculate approved_limit before saving
            monthly_income = serializer.validated_data['monthly_income']
            approved_limit = round(36 * monthly_income / 100000) * 100000

            # Save customer with approved_limit set
            customer = serializer.save(approved_limit=approved_limit)

            response_serializer = CustomerSerializer(customer)
            return Response(response_serializer.data, status=status.HTTP_201_CREATED)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CheckEligibility(APIView):
    def post(self, request):
        data = request.data

        # Validate required input fields
        required_fields = ['customer_id', 'loan_amount', 'interest_rate', 'tenure']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return Response(
                {"error": f"Missing fields: {', '.join(missing_fields)}"},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            customer = Customer.objects.get(customer_id=data['customer_id'])
            loans = Loan.objects.filter(customer=customer)
            loan_amount = float(data['loan_amount'])
            interest_rate = float(data['interest_rate'])
            tenure = int(data['tenure'])

            credit_score = calculate_credit_score(customer, loans, loan_amount)

            approval = False
            corrected_interest_rate = interest_rate
            msg = ""

            # Calculate sum of active loans' monthly repayments
            sum_current_emis = sum(loan.monthly_repayment for loan in loans if loan.active)

            if sum_current_emis > 0.5 * customer.monthly_income:
                approval = False
                msg = "Current EMIs exceed 50% of monthly income."
            else:
                if credit_score > 50:
                    approval = True
                elif 30 < credit_score <= 50:
                    approval = True
                    if corrected_interest_rate < 12:
                        corrected_interest_rate = 12.0
                elif 10 < credit_score <= 30:
                    approval = True
                    if corrected_interest_rate < 16:
                        corrected_interest_rate = 16.0
                else:
                    approval = False
                    msg = "Credit score too low."

            monthly_installment = calculate_emi(loan_amount, corrected_interest_rate, tenure)

            return Response({
                "customer_id": customer.customer_id,
                "approval": approval,
                "interest_rate": interest_rate,
                "corrected_interest_rate": corrected_interest_rate,
                "tenure": tenure,
                "monthly_installment": monthly_installment,
                "credit_score": credit_score,
                "message": msg
            }, status=status.HTTP_200_OK)

        except Customer.DoesNotExist:
            return Response({"error": "Customer not found."}, status=status.HTTP_404_NOT_FOUND)

        except ValueError:
            return Response({"error": "Invalid data type for loan_amount, interest_rate, or tenure."},
                            status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


class CreateLoan(APIView):
    def post(self, request):
        try:
            serializer = CreateLoanSerializer(data=request.data)
            if serializer.is_valid():
                customer = Customer.objects.get(customer_id=serializer.validated_data['customer_id'])
                loans = Loan.objects.filter(customer=customer)
                loan_amount = serializer.validated_data['loan_amount']
                interest_rate = serializer.validated_data['interest_rate']
                tenure = serializer.validated_data['tenure']

                credit_score = calculate_credit_score(customer, loans, loan_amount)
                sum_current_emis = sum(l.monthly_repayment for l in loans if l.active)

                approval = False
                corrected_interest_rate = interest_rate
                msg = ""

                if sum_current_emis > 0.5 * customer.monthly_income:
                    approval = False
                    msg = "Current EMIs exceed 50% salary."
                elif credit_score > 50:
                    approval = True
                elif 50 >= credit_score > 30:
                    if corrected_interest_rate < 12:
                        approval = True
                        corrected_interest_rate = 12.0
                    else:
                        approval = True
                elif 30 >= credit_score > 10:
                    if corrected_interest_rate < 16:
                        approval = True
                        corrected_interest_rate = 16.0
                    else:
                        approval = True
                else:
                    approval = False
                    msg = "Credit score too low."

                emi = calculate_emi(loan_amount, corrected_interest_rate, tenure)

                if approval:
                    today = date.today()
                    end_date = today + timedelta(days=30 * tenure)

                    loan = Loan.objects.create(
                        customer=customer,
                        loan_amount=loan_amount,
                        tenure=tenure,
                        interest_rate=corrected_interest_rate,
                        monthly_repayment=emi,
                        emis_paid_on_time=0,
                        start_date=today,
                        end_date=end_date,
                        active=True,
                    )
                    customer.current_debt += loan_amount
                    customer.save()

                    response_serializer = LoanSerializer(loan)
                    return Response({
                        "loan": response_serializer.data,
                        "loan_approved": True,
                        "message": "Loan approved.",
                        "monthly_installment": emi
                    }, status=status.HTTP_201_CREATED)

                else:
                    return Response({
                        "loan_approved": False,
                        "message": msg or "Loan not approved.",
                        "monthly_installment": None
                    }, status=status.HTTP_200_OK)

            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        except Customer.DoesNotExist:
            return Response({
                "loan_approved": False,
                "message": "Customer not found.",
                "monthly_installment": None
            }, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            return Response({
                "loan_approved": False,
                "message": str(e),
                "monthly_installment": None
            }, status=status.HTTP_400_BAD_REQUEST)


class ViewLoan(APIView):
    def get(self, request, loan_id):
        try:
            loan = Loan.objects.get(id=loan_id)
            serializer = LoanSerializer(loan)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Loan.DoesNotExist:
            return Response({"error": "Loan not found."}, status=status.HTTP_404_NOT_FOUND)


class ViewLoansForCustomer(APIView):
    def get(self, request, customer_id):
        loans = Loan.objects.filter(customer_id=customer_id, active=True)
        serializer = LoanSerializer(loans, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
